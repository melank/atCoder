# 家の強盗（House Robber）

## 難易度
★★☆☆☆（初級）

## アルゴリズム
動的計画法（DP）

## 問題

あなたは泥棒で、一列に並んだ家から盗みを働こうとしています。
各家には一定の金額が置いてあり、配列 `nums` で与えられます。

ただし、**隣り合う2つの家から連続して盗むと警報が鳴ってしまいます**。

警報を鳴らさずに盗める金額の最大値を求めてください。

## 入出力例

### 例1
```
入力: nums = [1, 2, 3, 1]
出力: 4
説明: 1番目の家（1）と3番目の家（3）から盗む → 1 + 3 = 4
```

### 例2
```
入力: nums = [2, 7, 9, 3, 1]
出力: 12
説明: 1番目（2）、3番目（9）、5番目（1）から盗む → 2 + 9 + 1 = 12
```

### 例3
```
入力: nums = [2, 1, 1, 2]
出力: 4
説明: 1番目（2）と4番目（2）から盗む → 2 + 2 = 4
```

### 例4
```
入力: nums = [5]
出力: 5
説明: 1軒しかないので、それを盗む
```

## 制約

- 1 <= len(nums) <= 100
- 0 <= nums[i] <= 400

## ヒント

### 状態の定義
- `dp[i]` = i番目の家まで見たときの最大金額

### 遷移式
各家で「盗む」か「盗まない」の2択があります：

```
dp[i] = max(
    dp[i-2] + nums[i],   // i番目を盗む（i-1は盗めない）
    dp[i-1]              // i番目を盗まない
)
```

### 考え方の例（nums = [2, 7, 9, 3, 1]）

| i | nums[i] | 盗む場合 | 盗まない場合 | dp[i] |
|---|---------|----------|--------------|-------|
| 0 | 2       | 2        | 0            | 2     |
| 1 | 7       | 0+7=7    | 2            | 7     |
| 2 | 9       | 2+9=11   | 7            | 11    |
| 3 | 3       | 7+3=10   | 11           | 11    |
| 4 | 1       | 11+1=12  | 11           | 12    |

### 空間最適化
- dp配列は直前2つの値だけ参照する
- 変数2つ（prev2, prev1）で O(1) 空間に最適化可能
