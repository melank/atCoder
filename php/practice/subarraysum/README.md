# 和がKになる部分配列の数

## 問題

```php
function solution($nums, $k) {
}
```

整数配列 `$nums` と整数 `$k` が与えられます。

**連続する部分配列** の要素の和が `$k` と等しくなるものの **個数** を返してください。

## 例

### 例1
```
入力 : nums = [1, 1, 1], k = 2
出力 : 2
```

**解説**:
- `nums[0..1] = [1, 1]` → 和 = 2 ✓
- `nums[1..2] = [1, 1]` → 和 = 2 ✓

### 例2
```
入力 : nums = [1, 2, 3], k = 3
出力 : 2
```

**解説**:
- `nums[0..1] = [1, 2]` → 和 = 3 ✓
- `nums[2..2] = [3]` → 和 = 3 ✓

### 例3
```
入力 : nums = [1, -1, 1, -1, 1], k = 0
出力 : 4
```

**解説**:
- `nums[0..1] = [1, -1]` → 和 = 0 ✓
- `nums[1..2] = [-1, 1]` → 和 = 0 ✓
- `nums[2..3] = [1, -1]` → 和 = 0 ✓
- `nums[0..3] = [1, -1, 1, -1]` → 和 = 0 ✓

### 例4
```
入力 : nums = [3, 4, 7, 2, -3, 1, 4, 2], k = 7
出力 : 4
```

**解説**:
- `[3, 4]`, `[7]`, `[7, 2, -3, 1]`, `[1, 4, 2]` の4つ

### 例5
```
入力 : nums = [1], k = 1
出力 : 1
```

## 制約

```
1 <= len(nums) <= 10000
-1000 <= nums[i] <= 1000
-10000000 <= k <= 10000000
```

## ヒント

### 単純な方法（遅い）
すべての部分配列を試す → O(N²) または O(N³)

### 累積和 + ハッシュマップ（速い）

累積和を使うと、区間 `[i, j]` の和は `prefix[j+1] - prefix[i]` で求まります。

これが `k` と等しいとき：
```
prefix[j+1] - prefix[i] = k
prefix[i] = prefix[j+1] - k
```

つまり、各位置で「今までに `prefix[j+1] - k` が何回出現したか」を数えればOK！

ハッシュマップで累積和の出現回数を記録しながら走査すると **O(N)** で解けます。
