# 区間マージ問題（大規模データ対応版）

## 問題

区間マージ問題と同じですが、制約がない（非常に大きなデータ）場合を考慮します。

## 計算量の分析

### 基本アルゴリズム

```
1. ソート: O(N log N)
2. マージ: O(N)
合計: O(N log N)
```

**ソートがボトルネック**であり、比較ベースのソートではこれが下限です。

### 制約がない場合の課題

| 課題 | 対策 |
|------|------|
| N が非常に大きい | メモリ効率の改善、ストリーミング |
| 値の範囲が非常に大きい | 座標圧縮は不要（端点だけ見ればよい） |
| 並列処理が必要 | 分割統治法 |

## 改善アプローチ

### 1. メモリ効率の改善

```php
// ❌ 悪い例：配列のコピーが発生
function solution(array $intervals): array {
    usort($intervals, ...);  // $intervals はコピー
}

// ✅ 良い例：参照渡しでコピーを避ける
function solution(array &$intervals): array {
    usort($intervals, ...);  // 元の配列を直接ソート
}
```

### 2. 分割統治法（Divide and Conquer）

大きな配列を分割し、各部分をマージしてから結果を統合。

```
intervals = [............................] (N個)
              ↓ 分割
        [..............] [..............]
              ↓ 再帰的にマージ
        [[1,5], [8,10]] [[2,6], [12,15]]
              ↓ 2つの結果を統合
        [[1,6], [8,10], [12,15]]
```

**利点**:
- 並列化可能（MapReduce パターン）
- メモリに収まらないデータも処理可能（外部ソート）

### 3. 2つのソート済みリストの統合

分割統治法の「統合」部分で使用：

```php
function mergeTwoSortedLists(array $a, array $b): array {
    // 2つのソート済み区間リストをマージ
    // Two Pointers で O(N + M)
}
```

## 計算量の比較

| アプローチ | 時間 | 空間 | 備考 |
|-----------|------|------|------|
| 基本 | O(N log N) | O(N) | シンプル |
| 参照渡し | O(N log N) | O(1) 追加 | コピー削減 |
| 分割統治 | O(N log N) | O(N) | 並列化可能 |

**注意**: 計算量のオーダーは変わりませんが、定数倍やメモリ効率が改善されます。

## 実装

このフォルダには2つの実装があります：

1. **solution**: 参照渡しでメモリ効率を改善
2. **solutionDivideAndConquer**: 分割統治法（並列化可能）

## 制約

```
1 <= len(intervals)（上限なし、非常に大きな N を想定）
0 <= start < end <= 10000
```
