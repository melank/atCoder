# 目標値の探索

## 難易度

初級（★★☆☆☆）

## 問題

昇順にソートされた整数配列 `$nums` と目標値 `$target` が与えられます。

`$target` が配列内に存在する場合はそのインデックス（0始まり）を、存在しない場合は `-1` を返す関数 `solution` を実装してください。

**制約上、効率的なアルゴリズムを使用する必要があります。**

## 例

### 例1
```
入力: nums = [1, 3, 5, 7, 9, 11], target = 7
出力: 3
```

**解説**: 7 は配列のインデックス 3 に存在します。

### 例2
```
入力: nums = [1, 3, 5, 7, 9, 11], target = 4
出力: -1
```

**解説**: 4 は配列に存在しません。

### 例3
```
入力: nums = [2, 4, 6, 8, 10], target = 2
出力: 0
```

**解説**: 2 は配列の先頭（インデックス 0）に存在します。

### 例4
```
入力: nums = [2, 4, 6, 8, 10], target = 10
出力: 4
```

**解説**: 10 は配列の末尾（インデックス 4）に存在します。

### 例5
```
入力: nums = [5], target = 5
出力: 0
```

**解説**: 要素が1つだけの配列でも正しく動作する必要があります。

## 制約

```
1 <= count($nums) <= 100000
-10^9 <= $nums[i] <= 10^9
-10^9 <= $target <= 10^9
配列は昇順にソートされている
配列内に重複する要素はない
```

## ヒント

配列が**ソート済み**であることを利用できます。

先頭から順番に探す方法（線形探索）では、最悪の場合 N 回の比較が必要で O(N) かかります。制約の N = 100,000 では問題ありませんが、より効率的な方法があります。

**二分探索**を使うと O(log N) で探索できます：

1. 探索範囲の中央の要素と目標値を比較
2. 目標値が中央より小さければ左半分を、大きければ右半分を探索
3. 範囲がなくなるまで繰り返す

時間計算量: O(log N)
