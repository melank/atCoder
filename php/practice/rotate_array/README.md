# 配列の回転

## 難易度

初級（★★☆☆☆）

## 問題

整数配列 `$nums` と非負整数 `$k` が与えられます。

配列を右に `$k` ステップ回転させた結果を返す関数 `solution` を実装してください。

「右に1ステップ回転」とは、配列の末尾の要素を先頭に移動させる操作です。

## 例

### 例1
```
入力: nums = [1, 2, 3, 4, 5], k = 2
出力: [4, 5, 1, 2, 3]
```

**解説**:
- 1回目の回転: [5, 1, 2, 3, 4]
- 2回目の回転: [4, 5, 1, 2, 3]

### 例2
```
入力: nums = [1, 2, 3], k = 1
出力: [3, 1, 2]
```

**解説**: 末尾の 3 が先頭に移動します。

### 例3
```
入力: nums = [1, 2, 3], k = 3
出力: [1, 2, 3]
```

**解説**: 3回回転すると元に戻ります（配列の長さと同じ回数の回転）。

### 例4
```
入力: nums = [1, 2, 3], k = 4
出力: [3, 1, 2]
```

**解説**: k=4 は k=1 と同じ結果になります（4 % 3 = 1）。

### 例5
```
入力: nums = [1], k = 5
出力: [1]
```

**解説**: 要素が1つの場合、何回回転しても変わりません。

## 制約

```
1 <= count($nums) <= 100000
-10^9 <= $nums[i] <= 10^9
0 <= $k <= 10^9
```

## ヒント

`$k` が配列の長さより大きい場合、余分な回転は意味がありません。`$k % count($nums)` で実際に必要な回転回数を求められます。

配列を回転させる方法はいくつかあります：
1. **スライス**: 配列を2つに分割して結合
2. **3回反転**: 全体を反転 → 前半を反転 → 後半を反転

時間計算量: O(N)
